services:
  postgres:
    image: postgres:16
    container_name: signchat_postgres
    restart: unless-stopped
    environment:
      POSTGRES_DB: signchat
      POSTGRES_USER: signchat
      POSTGRES_PASSWORD: signchat
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data

  redis:
    image: redis:7
    container_name: signchat_redis
    restart: unless-stopped
    ports:
      - "6379:6379"

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: signchat_backend
    restart: unless-stopped
    env_file:
      - ./backend/.env.example
    environment:
      LAN_IP: "${LAN_IP:-}"
    volumes:
      - ./backend:/app
      - ${HOME}/certs:/certs:ro
    ports:
      - "8000:8000"
    depends_on:
      - postgres
      - redis
    command: >
      sh -c "
      python manage.py migrate &&
      python -m daphne -b 0.0.0.0 -p 8000 core.asgi:application
      "

  backend_tls:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: signchat_backend_tls
    restart: unless-stopped
    env_file:
      - ./backend/.env.example
    environment:
      # LAN_IP is read by settings.py _build_allowed_hosts / _build_csrf_trusted_origins.
      # Default "" is safe: settings.py filters out empty strings.
      LAN_IP: "${LAN_IP:-}"
      DJANGO_ALLOWED_HOSTS: "localhost,127.0.0.1,0.0.0.0,${LAN_IP:-}"
      DJANGO_CSRF_TRUSTED_ORIGINS: "https://localhost:3000,https://${LAN_IP:-127.0.0.1}:3000"
      DJANGO_CORS_ALLOWED_ORIGINS: "https://localhost:3000,https://${LAN_IP:-127.0.0.1}:3000"
    volumes:
      - ./backend:/app
      - ${HOME}/certs:/certs:ro
    ports:
      - "8001:8001"
    depends_on:
      - postgres
      - redis
      - backend
    command: >
      sh -c "
      test -f /certs/dev.pem && test -f /certs/dev-key.pem || (echo '[backend_tls] missing certs in /certs' && exit 1);
      python -m daphne -e 'ssl:8001:interface=0.0.0.0:privateKey=/certs/dev-key.pem:certKey=/certs/dev.pem' core.asgi:application
      "

  # ── TURN server (coturn) ────────────────────────────────
  # Provides relay candidates for WebRTC when direct P2P / STUN fails
  # (e.g. symmetric NAT, cellular ↔ Wi-Fi cross-network).
  #
  # REQUIRED env vars (set before `docker compose up`):
  #   TURN_EXTERNAL_IP  — the IP that BOTH peers can reach.
  #     • LAN-only dev:   your Wi-Fi IP (e.g. 192.168.1.42)
  #     • Cloud / public:  the public IP (e.g. 203.0.113.10)
  #     • Behind NAT:      "PUBLIC_IP/PRIVATE_IP" (e.g. "203.0.113.10/10.0.0.5")
  #     • Tailscale:       your Tailscale IP (e.g. 100.64.x.x)
  #
  # Credentials must match NEXT_PUBLIC_ICE_SERVERS in frontend/.env.local.
  turn:
    image: coturn/coturn:4.6
    container_name: signchat_turn
    restart: unless-stopped
    ports:
      - "3478:3478/udp"
      - "3478:3478/tcp"
      - "49152-49252:49152-49252/udp"
    command:
      - -n
      - --log-file=stdout
      - --listening-ip=0.0.0.0
      - --listening-port=3478
      - --min-port=49152
      - --max-port=49252
      - --realm=${TURN_REALM:-signchat.local}
      - --user=${TURN_USER:-signchat}:${TURN_PASS:-signchat}
      - --external-ip=${TURN_EXTERNAL_IP:?Set TURN_EXTERNAL_IP before starting (see docs/webrtc-connectivity.md)}
      - --lt-cred-mech
      - --fingerprint
      - --no-cli
      - --no-tlsv1
      - --no-tlsv1_1

volumes:
  pgdata:
