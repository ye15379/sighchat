services:
  postgres:
    image: postgres:16
    container_name: signchat_postgres
    restart: unless-stopped
    environment:
      POSTGRES_DB: signchat
      POSTGRES_USER: signchat
      POSTGRES_PASSWORD: signchat
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data

  redis:
    image: redis:7
    container_name: signchat_redis
    restart: unless-stopped
    ports:
      - "6379:6379"

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: signchat_backend
    restart: unless-stopped
    env_file:
      - ./backend/.env.example
    environment:
      LAN_IP: "${LAN_IP:-}"
    volumes:
      - ./backend:/app
      - ${HOME}/certs:/certs:ro
    ports:
      - "8000:8000"
    depends_on:
      - postgres
      - redis
    command: >
      sh -c "
      python manage.py migrate &&
      python -m daphne -b 0.0.0.0 -p 8000 core.asgi:application
      "

  backend_tls:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: signchat_backend_tls
    restart: unless-stopped
    env_file:
      - ./backend/.env.example
    environment:
      # LAN_IP is read by settings.py _build_allowed_hosts / _build_csrf_trusted_origins.
      # Default "" is safe: settings.py filters out empty strings.
      LAN_IP: "${LAN_IP:-}"
      DJANGO_ALLOWED_HOSTS: "localhost,127.0.0.1,0.0.0.0,${LAN_IP:-}"
      DJANGO_CSRF_TRUSTED_ORIGINS: "https://localhost:3000,https://${LAN_IP:-127.0.0.1}:3000"
      DJANGO_CORS_ALLOWED_ORIGINS: "https://localhost:3000,https://${LAN_IP:-127.0.0.1}:3000"
    volumes:
      - ./backend:/app
      - ${HOME}/certs:/certs:ro
    ports:
      - "8001:8001"
    depends_on:
      - postgres
      - redis
      - backend
    command: >
      sh -c "
      test -f /certs/dev.pem && test -f /certs/dev-key.pem || (echo '[backend_tls] missing certs in /certs' && exit 1);
      python -m daphne -e 'ssl:8001:interface=0.0.0.0:privateKey=/certs/dev-key.pem:certKey=/certs/dev.pem' core.asgi:application
      "

  # ── TURN server (coturn) ────────────────────────────────
  # Optional — only needed when testing WebRTC across NATs.
  # Start with: docker compose --profile webrtc up -d turn
  #
  # REQUIRED env var: TURN_EXTERNAL_IP (checked at container start).
  #   Generate automatically: ./scripts/dev-env.sh
  #   Or export manually:     export TURN_EXTERNAL_IP=192.168.1.42
  #   See docs/webrtc-connectivity.md for details.
  turn:
    image: coturn/coturn:4.6
    container_name: signchat_turn
    restart: unless-stopped
    profiles: ["webrtc"]
    ports:
      - "3478:3478/udp"
      - "3478:3478/tcp"
      - "49152-49252:49152-49252/udp"
    environment:
      TURN_EXTERNAL_IP: "${TURN_EXTERNAL_IP:-}"
      TURN_REALM: "${TURN_REALM:-signchat.local}"
      TURN_USER: "${TURN_USER:-signchat}"
      TURN_PASS: "${TURN_PASS:-signchat}"
    entrypoint: ["sh", "-c"]
    command:
      - |
        if [ -z "$$TURN_EXTERNAL_IP" ]; then
          echo "════════════════════════════════════════════════════"
          echo "ERROR: TURN_EXTERNAL_IP is not set."
          echo ""
          echo "  Auto-detect:  ./scripts/dev-env.sh"
          echo "  Manual:       export TURN_EXTERNAL_IP=<your-ip>"
          echo "  Docs:         docs/webrtc-connectivity.md"
          echo "════════════════════════════════════════════════════"
          exit 1
        fi
        exec turnserver \
          --log-file=stdout \
          --listening-ip=0.0.0.0 \
          --listening-port=3478 \
          --min-port=49152 \
          --max-port=49252 \
          --realm="$$TURN_REALM" \
          --user="$$TURN_USER:$$TURN_PASS" \
          --external-ip="$$TURN_EXTERNAL_IP" \
          --lt-cred-mech \
          --fingerprint \
          --no-cli \
          --no-tls \
          --no-dtls \
          --no-tlsv1 \
          --no-tlsv1_1

volumes:
  pgdata:
